乐观锁和悲观锁：

悲观锁：
	它指的是对数据被外界(包括本系统当前的其他事务，以及来自外部系统的事务处理)修改保持保守态度。因此，在整个数据处理过程中，将数据处于锁定状态。
	缺陷：不论是页锁还是行锁，加锁的时间可能会很长，这样可能会长时间的限制其他用户的访问。也就是说悲观锁的并发访问性不好
	
	mysql中使用悲观锁：
		select status from t_goods where id=1 for update
		这样就开启了排它锁的方式实现了悲观锁，id=1那条数据被锁定，其他事务必须等待本次事务提交之后才能执行，可以保证当前数据不会被其他事务所修改。InnoDB默认使用行级锁，而行级锁是基于索引实现的，如果一条sql语句用不到索引是不会使用行级锁的，会使用表级锁将整个表锁住
		
	优点与不足：
		悲观锁并发控制实际上是先取锁再访问的保守策略，为数据处理的安全提供了保证。但在效率方面，处理加锁的机制让数据库产生额外的开销，增加了死锁的机会。另外在只读的事务处理中由于不会产生冲突，也没必要使用锁。
		
乐观锁：
	相对于悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则拒绝更新并返回用户错误的信息，让用户决定如何去做
	乐观锁由程序实现，不会存在死锁问题，但不会解决脏读问题
	相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的方式就是记录数据库版本
	
	优点和不足：
		乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。
	